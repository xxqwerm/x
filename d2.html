
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pixel Art Helmet Head Upper to Neck</title>
    <style>
        body { background-color: black; display: flex; justify-content: center; align-items: center; height: 100vh; margin: 0; }
        canvas { border: 1px solid #fff; }
    </style>
</head>
<body>
    <canvas id="pixelCanvas" width="512" height="512"></canvas> <!-- Reduced height to focus upper to neck -->
    <script>
        const canvas = document.getElementById('pixelCanvas');
        const ctx = canvas.getContext('2d');
        const pixelSize = 1; // Pixel-by-pixel for detail
        const gridWidth = canvas.width / pixelSize;
        const gridHeight = canvas.height / pixelSize;

        // Refined colors from image analysis
        const colors = {
            black: '#000000',
            darkNavy: '#0a0a1e',
            navy: '#1a1a3a',
            deepBlue: '#002244',
            mediumBlue: '#004488',
            lightBlue: '#3399ff',
            cyan: '#00ccff',
            darkPurple: '#330066',
            purple: '#6600cc',
            darkOrange: '#993300',
            mediumOrange: '#cc6600',
            orange: '#ff6600',
            brightOrange: '#ff9933',
            yellow: '#ffff00',
            redOrange: '#cc3300',
            darkRed: '#660000'
        };

        // Grid for pixels
        let grid = Array.from({ length: gridHeight }, () => Array(gridWidth).fill(colors.darkNavy));

        // Draw function
        function drawPixel(x, y, color) {
            if (x >= 0 && x < gridWidth && y >= 0 && y < gridHeight) {
                ctx.fillStyle = color;
                ctx.fillRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);
                grid[y][x] = color;
            }
        }

        // Background with subtle noise
        function addBackgroundNoise() {
            for (let y = 0; y < gridHeight; y++) {
                for (let x = 0; x < gridWidth; x++) {
                    if (Math.random() < 0.01) {
                        grid[y][x] = colors.navy;
                    } else if (Math.random() < 0.002) {
                        grid[y][x] = colors.cyan;
                    } else if (Math.random() < 0.001) {
                        grid[y][x] = colors.orange;
                    }
                }
            }
        }

        // Detailed hexagonal border with gradients and glow
        function drawHexagonalBorder() {
            // Top yellow spike
            drawPixel(255, 40, colors.yellow);
            drawPixel(256, 40, colors.yellow);
            drawPixel(257, 40, colors.yellow);
            drawPixel(254, 50, colors.brightOrange);
            drawPixel(255, 50, colors.yellow);
            drawPixel(256, 50, colors.yellow);
            drawPixel(257, 50, colors.yellow);
            drawPixel(258, 50, colors.brightOrange);
            drawPixel(253, 60, colors.orange);
            drawPixel(254, 60, colors.brightOrange);
            drawPixel(255, 60, colors.brightOrange);
            drawPixel(256, 60, colors.brightOrange);
            drawPixel(257, 60, colors.brightOrange);
            drawPixel(258, 60, colors.brightOrange);
            drawPixel(259, 60, colors.orange);

            // Left top slant
            let leftX = 256, leftY = 70;
            for (let i = 0; i < 120; i++) {
                drawPixel(leftX - i, leftY + i, colors.orange);
                drawPixel(leftX - i - 1, leftY + i, colors.mediumOrange);
                drawPixel(leftX - i + 1, leftY + i, colors.darkOrange);
                if (i % 8 === 0) drawPixel(leftX - i - 2, leftY + i, colors.brightOrange); // Glow
            }

            // Right top slant
            let rightX = 256, rightY = 70;
            for (let i = 0; i < 120; i++) {
                drawPixel(rightX + i, rightY + i, colors.orange);
                drawPixel(rightX + i + 1, rightY + i, colors.mediumOrange);
                drawPixel(rightX + i - 1, rightY + i, colors.darkOrange);
                if (i % 8 === 0) drawPixel(rightX + i + 2, rightY + i, colors.brightOrange);
            }

            // Vertical sides (approximated for hex)
            for (let i = 0; i < 200; i++) {
                drawPixel(136, 190 + i, colors.orange); // Left vertical
                drawPixel(135, 190 + i, colors.darkOrange);
                drawPixel(376, 190 + i, colors.orange); // Right vertical
                drawPixel(377, 190 + i, colors.darkOrange);
            }

            // Bottom slants
            let bottomLeftX = 136, bottomLeftY = 390;
            for (let i = 0; i < 120; i++) {
                drawPixel(bottomLeftX + i, bottomLeftY + i, colors.redOrange);
                drawPixel(bottomLeftX + i + 1, bottomLeftY + i, colors.darkRed);
                if (i % 5 === 0) drawPixel(bottomLeftX + i - 1, bottomLeftY + i, colors.orange);
            }

            let bottomRightX = 376, bottomRightY = 390;
            for (let i = 0; i < 120; i++) {
                drawPixel(bottomRightX - i, bottomRightY + i, colors.redOrange);
                drawPixel(bottomRightX - i - 1, bottomRightY + i, colors.darkRed);
                if (i % 5 === 0) drawPixel(bottomRightX - i + 1, bottomRightY + i, colors.orange);
            }

            // Scattered glow
            drawPixel(250, 100, colors.yellow);
            drawPixel(262, 100, colors.yellow);
            drawPixel(240, 150, colors.brightOrange);
            drawPixel(272, 150, colors.brightOrange);
        }

        // Detailed helmet top with spike/horn
        function drawHelmetTop() {
            // Top horn/spike extension
            for (let i = 0; i < 60; i++) {
                drawPixel(256, 70 + i, colors.mediumBlue);
                drawPixel(255, 70 + i, colors.deepBlue);
                drawPixel(257, 70 + i, colors.deepBlue);
                if (i % 10 === 0) {
                    drawPixel(254, 70 + i, colors.lightBlue); // Highlights
                    drawPixel(258, 70 + i, colors.lightBlue);
                }
            }

            // Curved helmet top
            for (let i = 0; i < 100; i++) {
                let curveOffset = Math.floor(Math.sin(i / 20) * 10);
                drawPixel(256 - i, 130 + Math.floor(i / 3) + curveOffset, colors.mediumBlue);
                drawPixel(256 + i, 130 + Math.floor(i / 3) + curveOffset, colors.mediumBlue);
                if (i % 5 === 0) {
                    drawPixel(256 - i, 129 + Math.floor(i / 3) + curveOffset, colors.lightBlue);
                    drawPixel(256 + i, 129 + Math.floor(i / 3) + curveOffset, colors.lightBlue);
                }
            }
        }

        // Detailed ears/side protrusions
        function drawEars() {
            // Left ear detailed
            for (let y = 250; y < 320; y++) {
                for (let x = 140; x < 170; x++) {
                    let dist = Math.sqrt((x - 155)**2 + (y - 285)**2);
                    if (dist < 20) {
                        drawPixel(x, y, colors.blue);
                        if (dist < 15) drawPixel(x, y, colors.mediumBlue);
                        if (dist < 10) drawPixel(x, y, colors.lightBlue); // Inner highlight
                    }
                }
            }
            // Shadows and details
            for (let i = 0; i < 10; i++) {
                drawPixel(150 + i, 300, colors.deepBlue);
                drawPixel(150, 280 + i, colors.deepBlue);
            }

            // Right ear detailed
            for (let y = 250; y < 320; y++) {
                for (let x = 342; x < 372; x++) {
                    let dist = Math.sqrt((x - 357)**2 + (y - 285)**2);
                    if (dist < 20) {
                        drawPixel(x, y, colors.blue);
                        if (dist < 15) drawPixel(x, y, colors.mediumBlue);
                        if (dist < 10) drawPixel(x, y, colors.lightBlue);
                    }
                }
            }
            for (let i = 0; i < 10; i++) {
                drawPixel(362 - i, 300, colors.deepBlue);
                drawPixel(362, 280 + i, colors.deepBlue);
            }
        }

        // Detailed nose/visor area
        function drawNose() {
            // Visor dark area
            for (let y = 280; y < 360; y++) {
                for (let x = 190; x < 322; x++) {
                    drawPixel(x, y, colors.black);
                    if ((x + y) % 15 === 0) drawPixel(x, y, colors.deepBlue); // Subtle pattern
                    if (Math.random() < 0.05) drawPixel(x, y, colors.purple); // Noise
                }
            }

            // Nose bridge detailed
            for (let i = 0; i < 30; i++) {
                drawPixel(256, 310 + i, colors.mediumBlue);
                drawPixel(255, 310 + i, colors.lightBlue);
                drawPixel(257, 310 + i, colors.lightBlue);
                drawPixel(254, 310 + i, colors.cyan);
                drawPixel(258, 310 + i, colors.cyan);
            }
            // Add flares
            drawPixel(256, 320, colors.cyan);
            drawPixel(256, 330, colors.lightBlue);
        }

        // Helmet body with detailed shading
        function drawHelmetBody() {
            // Fill helmet interior with gradient blues and purples
            for (let y = 130; y < 450; y++) { // Up to neck level
                for (let x = 136; x < 376; x++) {
                    if (grid[y][x] === colors.darkNavy || grid[y][x] === colors.navy) {
                        let shade = (x - 136) / 240; // Left to right gradient
                        let verticalShade = (y - 130) / 320;
                        if (shade + verticalShade < 0.4) grid[y][x] = colors.deepBlue;
                        else if (shade + verticalShade < 0.7) grid[y][x] = colors.mediumBlue;
                        else if (shade + verticalShade < 1.0) grid[y][x] = colors.lightBlue;
                        else grid[y][x] = colors.purple;
                        if (Math.random() < 0.1) grid[y][x] = colors.purple; // Random flecks
                    }
                }
            }

            // Center highlights and details
            for (let i = 0; i < 100; i++) {
                drawPixel(256, 180 + i, colors.lightBlue);
                drawPixel(255, 180 + i, colors.cyan);
                drawPixel(257, 180 + i, colors.cyan);
                if (i % 10 === 0) {
                    drawPixel(254, 180 + i, colors.white); // Bright spots
                    drawPixel(258, 180 + i, colors.white);
                }
            }
        }

        // Dynamic simulation for drips at neck level
        let drips = [];
        function createDrip() {
            drips.push({
                x: 136 + Math.floor(Math.random() * 240),
                y: 450, // Start at neck/bottom of helmet
                color: Math.random() > 0.6 ? colors.cyan : (Math.random() > 0.3 ? colors.brightOrange : colors.lightBlue),
                speed: 0.1 + Math.random() * 0.3,
                length: 3 + Math.floor(Math.random() * 8)
            });
        }

        function updateDrips() {
            for (let i = drips.length - 1; i >= 0; i--) {
                drips[i].y += drips[i].speed;
                if (drips[i].y > gridHeight + drips[i].length) {
                    drips.splice(i, 1);
                }
            }
        }

        function drawDrips() {
            drips.forEach(drip => {
                for (let t = 0; t < drip.length; t++) {
                    let y = Math.floor(drip.y - t);
                    if (y >= 0 && y < gridHeight) {
                        drawPixel(drip.x, y, drip.color);
                        drawPixel(drip.x - 1, y, drip.color); // Widen slightly
                        if (t > 0) {
                            ctx.globalAlpha = 0.7 - (t / drip.length) * 0.7;
                            drawPixel(drip.x, y, drip.color);
                            ctx.globalAlpha = 1;
                        }
                    }
                }
            });
        }

        // Render
        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            for (let y = 0; y < gridHeight; y++) {
                for (let x = 0; x < gridWidth; x++) {
                    ctx.fillStyle = grid[y][x];
                    ctx.fillRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);
                }
            }
            drawDrips();
        }

        // Animation
        function animate() {
            if (Math.random() < 0.08) createDrip();
            updateDrips();
            render();
            requestAnimationFrame(animate);
        }

        // Init
        addBackgroundNoise();
        drawHexagonalBorder();
        drawHelmetTop();
        drawEars();
        drawNose();
        drawHelmetBody();
        animate();
    </script>
</body>
</html>
```
